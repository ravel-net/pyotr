import random
import psycopg2
import re
import sys
from os.path import dirname, abspath, join
root = dirname(dirname(dirname(abspath(__file__))))
print(root)
sys.path.append(root)


def display(tuples, self_tuples):
    print("\n***********Tableau***********")
    for t in tuples:
        print(t)
    print("-----------")   
    for t in self_tuples:
        print(t)

    print("****************************\n")

def get_max(overlay):
    max_val = 0
    for node in overlay:
        if int(node) > max_val:
            max_val = int(node)
    return max_val

def isIPAddress(opd):
    return len(opd.split(".")) == 4

# Assumes that the condition c is of the form "var opr constant".
def extractWhereCondition(c, i, variableList):
    c = c.strip()
    match = re.search('!=|<=|>=|<>|<|>|==', c)
    left_opd = c[:match.span()[0]].strip()
    opr = match.group()
    right_opd = c[match.span()[1]:].strip()
    column_name = variableList[left_opd][0] # TODO: Check if variable is in the tableau or not
    condition = ""
    if (opr == "=="): # TODO: Make this conversion better
        opr = "="
    condition = ["{} {} '{}'".format(column_name, opr, right_opd)]
    return condition

# Takes a tableau query and substitutes the summary of that query with the summary of the instance tableau (i.e. any variables in the query must map to the corresponding values in the data instance summary)
# Note: The index of summary_query and summary_instance matter
def summary_substitutions(tableau_query, summary_query, summary_instance):
	substituted_tableau = []
	for i, tuple in enumerate(tableau_query):
		new_tuple = ()
		for col, val in enumerate(tuple):
			curr_val = val
			for index, answer in enumerate(summary_query):
				if answer in val: # if a matching entry is found
					substitution = summary_instance[index]  
					curr_val = val.replace(answer, substitution)
			new_tuple += (curr_val,)
		substituted_tableau.append(new_tuple)
	return substituted_tableau, summary_instance

def general_convert_tableau_to_sql(tableau, tablename, query_summary, column_names):
    """
    Convert tableau to corresponding SQL

    Parameters:
    ------------
    tableau : list 
        The tableau tuples(non self-connected) and self-connected tuples in forwarding order, 
        generated by gen_tableau() function (tuples + self_tuples) or retrieved from database table.
        For example, path 1 -> 2 -> 3, the tableau tuples are [(1, 5, {}), (5, 2, {}), (2, 3, {}), (1, 1, {}), (2, 2, {})], 
        node 2 is split into 2 and 5(interface, calculated by adding 2 and the max value among the virtual nodes, here is 3).

    tablename : string 
        The name of data table in database that stores the tableau

    query_summary : list
        the summary of program/query tableau    

    column_names : list
        the list of column names in the network

    Returns:
    ------------
    sql : string
        The sql string that can directly run in Postgres 
    """
    # cols = []
    tables = []
    constraints = []
    variableList = {}
    summary = set()
    summary_nodes = []
    for i, tuple in enumerate(tableau):
        tables.append("{} t{}".format(tablename, i))
        for col, val in enumerate(tuple):
            if len(val) < 1:
                continue
            elif column_names[col] == 'condition' and val:
                conditionList = val.split(",")
                for c in conditionList:
                    constraints += extractWhereCondition(c, i, variableList)
            elif val[0].isdigit():
                constraints.append("t{}.{} = '{}'".format(i, column_names[col], val))
            else: # variable
                if val not in variableList:
                    variableList[val] = []
                variableList[val].append("t{}.{}".format(i, column_names[col]))
            if val in query_summary and val not in summary:
                summary.add(val)
                summary_nodes.append('t{}.{}'.format(i, column_names[col]))
    for var in variableList:
        for i in range(len(variableList[var])-1):
            constraints.append(variableList[var][i] + " = " + variableList[var][i+1])


    sql = "select " + ", ".join(summary_nodes) + " from " + ", ".join(tables) + " where " + " and ".join(constraints)
    return sql

def convert_tableau_to_sql(tableau, tablename, overlay_nodes, column_names):
    """
    Convert tableau to corresponding SQL

    Parameters:
    ------------
    tableau : list 
        The tableau tuples(non self-connected) and self-connected tuples in forwarding order, 
        generated by gen_tableau() function (tuples + self_tuples) or retrieved from database table.
        For example, path 1 -> 2 -> 3, the tableau tuples are [(1, 5, {}), (5, 2, {}), (2, 3, {}), (1, 1, {}), (2, 2, {})], 
        node 2 is split into 2 and 5(interface, calculated by adding 2 and the max value among the virtual nodes, here is 3).

    tablename : string 
        The name of data table in database that stores the tableau

    overlay_nodes : list
        the list of constant nodes in overlay network

    Returns:
    ------------
    sql : string
        The sql string that can directly run in Postgres 
    """
    # cols = []
    tables = []
    constraints = []
    
    last = ""
    last_F = ""
    var_dict = {}
    summary = {}
    summary_nodes = []
    for i in range(len(tableau)):
        tables.append("{} t{}".format(tablename, i))
        n1 = tableau[i][0]
        n2 = tableau[i][1]


        # Extra logic to handle firewalls. Should be automated
        if (len(tableau[i]) > 3): # when conditions occur
            for j, column in enumerate(column_names):
                val = tableau[i][j]
                if val in overlay_nodes and val not in summary:
                    summary[val] = 't{}.{}'.format(i, column)
                    summary_nodes.append('t{}.{}'.format(i, column))
            conditions = tableau[i][3]

            if conditions != "":
                conditionList = conditions.split(",")
                for c in conditionList:
                    constraints.append(extractWhereCondition(c, i, column_names))



        if n1.isdigit() or isIPAddress(n1):
            constraints.append("t{}.n1 = '{}'".format(i, n1))
        
        if n2.isdigit() or isIPAddress(n2):
            constraints.append("t{}.n2 = '{}'".format(i, n2))

        if n1 == last and not n1.isdigit():
            constraints.append("t{}.n2 = t{}.n1".format(i-1, i))
            var_dict[n1] = i
            if (len(tableau[i]) > 2): # for firewalls
                constraints.append("t{}.{} = t{}.{}".format(i-1, column_names[2], i, column_names[2]))

        if not n1.isdigit() and not n2.isdigit() and n1 == n2:
            constraints.append("t{}.n1 = t{}.n2".format(i, i))
            if n1 in var_dict.keys():
                constraints.append("t{}.n1 = t{}.n2".format(var_dict[n1], i))


        last = n2

    sql = "select " + ", ".join(summary_nodes) + " from " + ", ".join(tables) + " where " + " and ".join(constraints)
    print(sql)
    return sql

# def convert_closure_group_to_sql(tableau, tablename, overlay_nodes):
#     """
#     Convert closure group to corresponding SQL

#     Parameters:
#     ------------
#     tableau : list 
#         The closure group tableau tuples(non self-connected) and self-connected tuples in forwarding order, 
#         generated by gen_tableau() function (tuples + self_tuples) or retrieved from database table.
#         For example, path 1 -> 2 -> 3, the tableau tuples are [(1, 5, {}), (5, 2, {}), (2, 3, {}), (1, 1, {}), (2, 2, {})], 
#         node 2 is split into 2 and 5(interface, calculated by adding 2 and the max value among the virtual nodes, here is 3).

#     tablename : string 
#         The name of data table in database that stores the tableau

#     overlay_nodes : list
#         the list of constant nodes in overlay network

#     Returns:
#     ------------
#     sql : string
#         The sql string that can directly run in Postgres 
#     """
#     max_val = get_max(overlay_nodes)
#     constant_cols = overlay_nodes.copy()
#     for i in range(len(overlay_nodes)):
#         if i == 0 or i == (len(overlay_nodes) - 1):
#             continue
#         constant_cols.append(str(int(overlay_nodes[i]) + max_val))
    
#     cols = []
#     tables = []
#     constraints = []
    
#     last = ""
#     var_dict = {}
    
#     for i in range(len(tableau)):
#         tables.append("{} t{}".format(tablename, i))
#         # (n1, n2, _) = tableau[i]
#         n1 = tableau[i][0]
#         n2 = tableau[i][1]

#         if n1 in constant_cols:
#             constraints.append("t{}.n1 = '{}'".format(i, n1))
#             if n1 != n2 and n1 != last:
#                 cols.append("t{}.n1".format(i))
#                 constant_cols.remove(n1)
            
#         if n2 in constant_cols:
#             if n1 != n2:
#                 cols.append("t{}.n2".format(i))
#                 constant_cols.remove(n2)
#             constraints.append("t{}.n2 = '{}'".format(i, n2))

#         if n1 == last and not n1.isdigit():
#             constraints.append("t{}.n2 = t{}.n1".format(i-1, i))
#             var_dict[n1] = i

#         if not n1.isdigit() and not n2.isdigit() and n1 == n2:
#             constraints.append("t{}.n1 = t{}.n2".format(i, i))
#             if n1 in var_dict.keys():
#                 constraints.append("t{}.n1 = t{}.n2".format(var_dict[n1], i))

#         last = n2
#     # print(cols)
#     # print(tables)
#     # print(constraints)
#     constant_col_sql = ", ".join(["{}".format(c) for c in constant_cols])
#     sql = "select " + constant_col_sql + ", " + ", ".join(cols) + " from " + ", ".join(tables) + " where " + " and ".join(constraints)
#     print(sql)
#     return sql



if __name__ == '__main__':
    size = 10 # the number of nodes in physical network path
    rate = 0.3 # the percentage of constant nodes in physical network path (the number of nodes in overlay path)

    physical_path, physical_nodes, overlay_path, overlay_nodes = gen_large_chain(size=size, rate=rate)

    physical_tuples, phy_self_tuples = gen_tableau(path=physical_path, overlay=overlay_nodes)

    display(physical_tuples, phy_self_tuples)

    overlay_tuples, ove_self_tuples = gen_tableau(path=overlay_path, overlay=overlay_nodes)

    display(overlay_tuples, ove_self_tuples)

    sql = convert_tableau_to_sql(phy_self_tuples+phy_self_tuples, "T_v", overlay_nodes)
    print(sql)